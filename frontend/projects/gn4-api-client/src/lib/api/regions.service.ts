/**
 * GeoNetwork 4.4.9 OpenAPI Documentation
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { Category } from '../model/category';
// @ts-ignore
import { ListRegionsResponse } from '../model/listRegionsResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class RegionsService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Get geometry as image
     * A rendering of the geometry as a &#x60;png&#x60;.    The coverage of the image is computed from the geometry envelope and size using scale factor configuration (See &#x60;regionGetMapExpandFactors&#x60; bean in &#x60;config-spring-geonetwork.xml&#x60;) to give enough context on where the geometry is. The smaller the geometry, the bigger the expand factor.   If needed, when the factor is high, square image mode can be enabled (instead of proportional geometry size):   &#x60;&#x60;&#x60;xml  &lt;util:set id&#x3D;\&quot;regionGetMapExpandFactors\&quot; set-class&#x3D;\&quot;java.util.TreeSet\&quot;&gt;     &lt;bean class&#x3D;\&quot;org.fao.geonet.api.records.extent.ExpandFactor\&quot;           p:proportion&#x3D;\&quot;.00005\&quot; p:factor&#x3D;\&quot;256\&quot; p:squareImage&#x3D;\&quot;true\&quot;/&gt; &#x60;&#x60;&#x60; 
     * @param mapsrs (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
     * @param width (optional) width of the image that is created. Only one of width and height are permitted
     * @param height (optional) height of the image that is created. Only one of width and height are permitted
     * @param background (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param geom (optional) a wkt or gml encoded geometry.
     * @param geomtype (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
     * @param geomsrs 
     * @param fillColor (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param strokeColor (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGeomAsImage(mapsrs?: string, width?: number, height?: number, background?: string, geom?: string, geomtype?: string, geomsrs?: string, fillColor?: string, strokeColor?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/png', context?: HttpContext, transferCache?: boolean}): Observable<Array<string>>;
    public getGeomAsImage(mapsrs?: string, width?: number, height?: number, background?: string, geom?: string, geomtype?: string, geomsrs?: string, fillColor?: string, strokeColor?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/png', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<string>>>;
    public getGeomAsImage(mapsrs?: string, width?: number, height?: number, background?: string, geom?: string, geomtype?: string, geomsrs?: string, fillColor?: string, strokeColor?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/png', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<string>>>;
    public getGeomAsImage(mapsrs?: string, width?: number, height?: number, background?: string, geom?: string, geomtype?: string, geomsrs?: string, fillColor?: string, strokeColor?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/png', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>mapsrs, 'mapsrs');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>width, 'width');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>height, 'height');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>background, 'background');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>geom, 'geom');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>geomtype, 'geomtype');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>geomsrs, 'geomsrs');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>fillColor, 'fillColor');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>strokeColor, 'strokeColor');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'image/png'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/regions/geom.png`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<string>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get list of region types
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRegionTypes(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<Array<Category>>;
    public getRegionTypes(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<Category>>>;
    public getRegionTypes(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<Category>>>;
    public getRegionTypes(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/regions/types`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<Category>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get list of regions
     * @param label 
     * @param categoryId 
     * @param maxRecords 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRegions(label?: string, categoryId?: string, maxRecords?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml', context?: HttpContext, transferCache?: boolean}): Observable<ListRegionsResponse>;
    public getRegions(label?: string, categoryId?: string, maxRecords?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ListRegionsResponse>>;
    public getRegions(label?: string, categoryId?: string, maxRecords?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ListRegionsResponse>>;
    public getRegions(label?: string, categoryId?: string, maxRecords?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>label, 'label');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>categoryId, 'categoryId');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>maxRecords, 'maxRecords');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json',
            'application/xml'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/regions`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ListRegionsResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
