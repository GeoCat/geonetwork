/**
 * GeoNetwork 4.4.9 OpenAPI Documentation
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { MetadataReplacementProcessingReport } from '../model/metadataReplacementProcessingReport';
// @ts-ignore
import { ProcessingReport } from '../model/processingReport';
// @ts-ignore
import { XsltMetadataProcessingReport } from '../model/xsltMetadataProcessingReport';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class ProcessesService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Clear process reports list
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProcessReport(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deleteProcessReport(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deleteProcessReport(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deleteProcessReport(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/reports`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get current process reports
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessReport(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<Array<ProcessingReport>>;
    public getProcessReport(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<ProcessingReport>>>;
    public getProcessReport(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<ProcessingReport>>>;
    public getProcessReport(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/reports`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<ProcessingReport>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Preview process result applied to one or more records
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \&#39;.csv\&#39;, the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @param process Process identifier
     * @param diffType Return differences with diff, diffhtml or patch
     * @param uuids Record UUIDs. If null current selection is used.
     * @param bucket Selection bucket name
     * @param appendFirst Append documents before processing
     * @param applyUpdateFixedInfo Apply update fixed info
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public previewProcessRecords(process: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, appendFirst?: boolean, applyUpdateFixedInfo?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public previewProcessRecords(process: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, appendFirst?: boolean, applyUpdateFixedInfo?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public previewProcessRecords(process: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, appendFirst?: boolean, applyUpdateFixedInfo?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public previewProcessRecords(process: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, appendFirst?: boolean, applyUpdateFixedInfo?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling previewProcessRecords.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>diffType, 'diffType');
        if (uuids) {
            uuids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'uuids');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>bucket, 'bucket');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>appendFirst, 'appendFirst');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>applyUpdateFixedInfo, 'applyUpdateFixedInfo');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/${this.configuration.encodeParam({name: "process", value: process, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Preview of search and replace text.
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @param search Value to search for
     * @param useRegexp Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param replace Replacement
     * @param regexpFlags regexpFlags
     * @param diffType Return differences with diff, diffhtml or patch
     * @param uuids Record UUIDs. If null current selection is used.
     * @param bucket Selection bucket name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public previewProcessSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public previewProcessSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public previewProcessSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public previewProcessSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, diffType?: 'patch' | 'diff' | 'diffhtml', uuids?: Array<string>, bucket?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling previewProcessSearchAndReplace.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>useRegexp, 'useRegexp');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>search, 'search');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>replace, 'replace');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>regexpFlags, 'regexpFlags');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>diffType, 'diffType');
        if (uuids) {
            uuids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'uuids');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>bucket, 'bucket');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/db/search-and-replace`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Apply a process to one or more records
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @param process Process identifier
     * @param uuids Record UUIDs. If null current selection is used.
     * @param bucket Selection bucket name
     * @param updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param index Index after processing
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public processRecords(process: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<XsltMetadataProcessingReport>;
    public processRecords(process: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<XsltMetadataProcessingReport>>;
    public processRecords(process: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<XsltMetadataProcessingReport>>;
    public processRecords(process: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (process === null || process === undefined) {
            throw new Error('Required parameter process was null or undefined when calling processRecords.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (uuids) {
            uuids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'uuids');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>bucket, 'bucket');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>updateDateStamp, 'updateDateStamp');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>index, 'index');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/${this.configuration.encodeParam({name: "process", value: process, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<XsltMetadataProcessingReport>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Apply a database search and replace to one or more records
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @param search Value to search for
     * @param useRegexp Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param replace Replacement
     * @param regexpFlags regexpFlags
     * @param uuids Record UUIDs. If null current selection is used.
     * @param bucket Selection bucket name
     * @param updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param index Index after processing
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public processSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<XsltMetadataProcessingReport>;
    public processSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<XsltMetadataProcessingReport>>;
    public processSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<XsltMetadataProcessingReport>>;
    public processSearchAndReplace(search: string, useRegexp?: boolean, replace?: string, regexpFlags?: string, uuids?: Array<string>, bucket?: string, updateDateStamp?: boolean, index?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling processSearchAndReplace.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>useRegexp, 'useRegexp');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>search, 'search');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>replace, 'replace');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>regexpFlags, 'regexpFlags');
        if (uuids) {
            uuids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'uuids');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>bucket, 'bucket');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>updateDateStamp, 'updateDateStamp');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>index, 'index');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/db/search-and-replace`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<XsltMetadataProcessingReport>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search and replace values in one or more ISO19139 records
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372&#x3D;metadata  * mdfield-1398155513728&#x3D;id.contact.individualName  * replaceValue-1398155513728&#x3D;Juan  * searchValue-1398155513728&#x3D;Jose  &lt;br/&gt;Batch editing can also be used for similar works.
     * @param process 
     * @param uuids Record UUIDs. If null current selection is used.
     * @param bucket Selection bucket name
     * @param isTesting Test only (ie. metadata are not saved). Return the report only.
     * @param isCaseInsensitive Case insensitive search.
     * @param vacuumMode \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @deprecated
     */
    public searchAndReplace(process?: string, uuids?: Array<string>, bucket?: string, isTesting?: boolean, isCaseInsensitive?: boolean, vacuumMode?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MetadataReplacementProcessingReport>;
    public searchAndReplace(process?: string, uuids?: Array<string>, bucket?: string, isTesting?: boolean, isCaseInsensitive?: boolean, vacuumMode?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MetadataReplacementProcessingReport>>;
    public searchAndReplace(process?: string, uuids?: Array<string>, bucket?: string, isTesting?: boolean, isCaseInsensitive?: boolean, vacuumMode?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MetadataReplacementProcessingReport>>;
    public searchAndReplace(process?: string, uuids?: Array<string>, bucket?: string, isTesting?: boolean, isCaseInsensitive?: boolean, vacuumMode?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>process, 'process');
        if (uuids) {
            uuids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'uuids');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>bucket, 'bucket');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>isTesting, 'isTesting');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>isCaseInsensitive, 'isCaseInsensitive');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>vacuumMode, 'vacuumMode');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/processes/search-and-replace`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<MetadataReplacementProcessingReport>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
