/**
 * GeoNetwork 4.4.9 OpenAPI Documentation
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

// @ts-ignore
import { Crs } from '../model/crs';
// @ts-ignore
import { SimpleMetadataProcessingReport } from '../model/simpleMetadataProcessingReport';
// @ts-ignore
import { ThesaurusInfo } from '../model/thesaurusInfo';
// @ts-ignore
import { UploadThesaurusRequest } from '../model/uploadThesaurusRequest';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { BaseService } from '../api.base.service';

@Injectable({
  providedIn: 'root',
})
export class RegistriesService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration,
  ) {
    super(basePath, configuration);
  }

  /**
   * Delete a thesaurus by name
   * Delete a thesaurus.
   * @param thesaurus Thesaurus to delete.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public deleteThesaurus(
    thesaurus: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling deleteThesaurus.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies/${this.configuration.encodeParam({ name: 'thesaurus', value: thesaurus, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Extracts directory entries from records
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).&lt;br/&gt;&lt;br/&gt;Only records that the current user can edit are analyzed.&lt;br/&gt;&lt;br/&gt;Examples:&lt;br/&gt;For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling extractEntries.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>bucket, 'bucket');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>xpath, 'xpath');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/actions/entries/collect`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get CRS
   * @param id CRS identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrs(
    id: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<Crs>;
  public getCrs(
    id: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<Crs>>;
  public getCrs(
    id: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<Crs>>;
  public getCrs(
    id: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getCrs.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/crs/${this.configuration.encodeParam({ name: 'id', value: id, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<Crs>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get list of CRS type
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrsTypes(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<Array<string>>;
  public getCrsTypes(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<Array<string>>>;
  public getCrsTypes(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<Array<string>>>;
  public getCrsTypes(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/crs/types`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<Array<string>>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get a directory entry
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * @param uuid Directory entry UUID.
   * @param process Process
   * @param transformation Transformation
   * @param lang lang
   * @param schema schema
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (uuid === null || uuid === undefined) {
      throw new Error('Required parameter uuid was null or undefined when calling getEntry.');
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (process) {
      process.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'process',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformation,
      'transformation',
    );
    if (lang) {
      lang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'lang',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>schema, 'schema');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/entries/${this.configuration.encodeParam({ name: 'uuid', value: uuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get keyword by id
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \&#39;to-iso19139-keyword\&#39; is the default and return an ISO19139 snippet.\&#39;to-iso19139-keyword-as-xlink\&#39; return an XLinked element. Custom transformation can be create on a per schema basis.
   * @param id Keyword identifier or list of keyword identifiers comma separated.
   * @param thesaurus Thesaurus to look info for the keyword(s).
   * @param lang Languages.
   * @param keywordOnly Only print the keyword, no thesaurus information.
   * @param transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param langMap langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getKeywordById.');
    }
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getKeywordById.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>id, 'id');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurus,
      'thesaurus',
    );
    if (lang) {
      lang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'lang',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>keywordOnly,
      'keywordOnly',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformation,
      'transformation',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>langMap,
      'langMap',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies/keyword`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get keyword by ids
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \&#39;to-iso19139-keyword\&#39; is the default and return an ISO19139 snippet.\&#39;to-iso19139-keyword-as-xlink\&#39; return an XLinked element. Custom transformation can be create on a per schema basis.This can be used instead of the GET method for cases where you need to submit large parameters list
   * @param id Keyword identifier or list of keyword identifiers comma separated.
   * @param thesaurus Thesaurus to look info for the keyword(s).
   * @param lang Languages.
   * @param keywordOnly Only print the keyword, no thesaurus information.
   * @param transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param langMap langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getKeywordByIds(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public getKeywordByIds(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public getKeywordByIds(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public getKeywordByIds(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getKeywordByIds.');
    }
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getKeywordByIds.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>id, 'id');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurus,
      'thesaurus',
    );
    if (lang) {
      lang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'lang',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>keywordOnly,
      'keywordOnly',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformation,
      'transformation',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>langMap,
      'langMap',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies/keyword`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Download a thesaurus by name
   * Download the thesaurus in SKOS format.
   * @param thesaurus Thesaurus to download.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getThesaurus(
    thesaurus: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<Blob>;
  public getThesaurus(
    thesaurus: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<Blob>>;
  public getThesaurus(
    thesaurus: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<Blob>>;
  public getThesaurus(
    thesaurus: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getThesaurus.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/xml', 'text/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let localVarPath = `/registries/vocabularies/${this.configuration.encodeParam({ name: 'thesaurus', value: thesaurus, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: 'blob',
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Uploads a CSV file and convert it to SKOS format
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param encoding Encoding. Default is UTF-8.
   * @param thesaurusNs Thesaurus namespace. Default is filename.
   * @param languages Thesaurus languages
   * @param thesaurusTitle Thesaurus title. Default is filename.
   * @param conceptIdColumn Column name for concept id. Default is id.
   * @param conceptLabelColumn Column name for concept label. Default is label.
   * @param conceptDescriptionColumn Column name for concept description. Default is description.
   * @param conceptBroaderIdColumn Column name for broader concept id. Default is broader.
   * @param conceptNarrowerIdColumn Column name for narrower concept id. Default is narrower.
   * @param conceptRelatedIdColumn Column name for related concept id. Default is related.
   * @param conceptLinkSeparator Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
   * @param importAsThesaurus Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
   * @param uploadThesaurusRequest
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>dir, 'dir');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>encoding,
      'encoding',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurusNs,
      'thesaurusNs',
    );
    if (languages) {
      languages.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'languages',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurusTitle,
      'thesaurusTitle',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptIdColumn,
      'conceptIdColumn',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptLabelColumn,
      'conceptLabelColumn',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptDescriptionColumn,
      'conceptDescriptionColumn',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptBroaderIdColumn,
      'conceptBroaderIdColumn',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptNarrowerIdColumn,
      'conceptNarrowerIdColumn',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptRelatedIdColumn,
      'conceptRelatedIdColumn',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptLinkSeparator,
      'conceptLinkSeparator',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>importAsThesaurus,
      'importAsThesaurus',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies/import/csv`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: uploadThesaurusRequest,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Import spatial directory entries
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * @param file The ZIP file to upload containing the Shapefile.
   * @param uuidAttribute Attribute to use for UUID. If none, random UUID are generated.
   * @param uuidPattern Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
   * @param descriptionAttribute Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
   * @param geomProjectionTo geomProjectionTo
   * @param lenient lenient
   * @param charset Attribute table charset
   * @param onlyBoundingBox Create only bounding box for each spatial objects.
   * @param process Process
   * @param schema Schema identifier
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<SimpleMetadataProcessingReport>;
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<SimpleMetadataProcessingReport>>;
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<SimpleMetadataProcessingReport>>;
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE',
    group?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (file === null || file === undefined) {
      throw new Error(
        'Required parameter file was null or undefined when calling importSpatialEntries.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidAttribute,
      'uuidAttribute',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidPattern,
      'uuidPattern',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>descriptionAttribute,
      'descriptionAttribute',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>geomProjectionTo,
      'geomProjectionTo',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>lenient,
      'lenient',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>charset,
      'charset',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>onlyBoundingBox,
      'onlyBoundingBox',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>process,
      'process',
    );
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>schema, 'schema');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidProcessing,
      'uuidProcessing',
    );
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>group, 'group');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['multipart/form-data'];

    const canConsumeForm = this.canConsumeForm(consumes);

    let localVarFormParams: { append(param: string, value: any): any };
    let localVarUseForm = false;
    let localVarConvertFormParamsToString = false;
    // use FormData to transmit files using content-type "multipart/form-data"
    // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
    localVarUseForm = canConsumeForm;
    if (localVarUseForm) {
      localVarFormParams = new FormData();
    } else {
      localVarFormParams = new HttpParams({ encoder: this.encoder });
    }

    if (file !== undefined) {
      localVarFormParams =
        (localVarFormParams.append('file', <any>file) as any) || localVarFormParams;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/actions/entries/import/spatial`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<SimpleMetadataProcessingReport>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: localVarConvertFormParamsToString
          ? localVarFormParams.toString()
          : localVarFormParams,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Preview directory entries extracted from records
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).&lt;br/&gt;&lt;br/&gt;Only records that the current user can edit are analyzed.&lt;br/&gt;&lt;br/&gt;Examples:&lt;br/&gt;For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling previewExtractedEntries.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>bucket, 'bucket');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>xpath, 'xpath');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/actions/entries/collect`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Preview updated matching entries in records
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).&lt;br/&gt;&lt;br/&gt;The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role/_*_/@codeListValue
   * @param substituteAsXLink Replace entry by XLink.
   * @param fq Filter query for directory search.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling previewUpdatedRecordEntries.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>bucket, 'bucket');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>xpath, 'xpath');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath',
    );
    if (propertiesToCopy) {
      propertiesToCopy.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'propertiesToCopy',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>substituteAsXLink,
      'substituteAsXLink',
    );
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>fq, 'fq');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/actions/entries/synchronize`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Search coordinate reference system (CRS)
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * @param q Search value
   * @param type Type of CRS
   * @param rows Number of results. Default is: 100
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchCrs(
    q?: string,
    type?: 'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS',
    rows?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<Array<Crs>>;
  public searchCrs(
    q?: string,
    type?: 'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS',
    rows?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<Array<Crs>>>;
  public searchCrs(
    q?: string,
    type?: 'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS',
    rows?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<Array<Crs>>>;
  public searchCrs(
    q?: string,
    type?: 'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS',
    rows?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>q, 'q');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>rows, 'rows');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/crs`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<Array<Crs>>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Search keywords
   * @param q Query
   * @param lang Query in that language
   * @param rows Number of rows
   * @param start Start from
   * @param pLang Return keyword information in one or more languages
   * @param thesaurus Thesaurus identifier
   * @param type Type of search
   * @param uri URI query
   * @param sort Sort by
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>q, 'q');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>lang, 'lang');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>rows, 'rows');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>start, 'start');
    if (pLang) {
      pLang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'pLang',
        );
      });
    }
    if (thesaurus) {
      thesaurus.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'thesaurus',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>uri, 'uri');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>sort, 'sort');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies/search`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update matching entries in records
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).&lt;br/&gt;&lt;br/&gt;The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role/_*_/@codeListValue
   * @param substituteAsXLink Replace entry by XLink.
   * @param fq Filter query for directory search.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<object>;
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<object>>;
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<object>>;
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling updateRecordEntries.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>bucket, 'bucket');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>xpath, 'xpath');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath',
    );
    if (propertiesToCopy) {
      propertiesToCopy.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'propertiesToCopy',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>substituteAsXLink,
      'substituteAsXLink',
    );
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>fq, 'fq');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/actions/entries/synchronize`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<object>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Updates the information of a local thesaurus
   * Updates the information of a local thesaurus.
   * @param thesaurus Thesaurus to update.
   * @param thesaurusInfo
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfo: ThesaurusInfo,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfo: ThesaurusInfo,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfo: ThesaurusInfo,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfo: ThesaurusInfo,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: undefined;
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling updateThesaurus.',
      );
    }
    if (thesaurusInfo === null || thesaurusInfo === undefined) {
      throw new Error(
        'Required parameter thesaurusInfo was null or undefined when calling updateThesaurus.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies/${this.configuration.encodeParam({ name: 'thesaurus', value: thesaurus, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: thesaurusInfo,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Uploads a new thesaurus from a file
   * Supported thesaurus are RDF/XML files using SKOS specification, OWL file describing NamedIndividual elements or SDMX file describing Codelist element. For RDF, extension must be .rdf or .xml, for OWL, .owl and for SDMX, .sdmx.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
   * @param uploadThesaurusRequest
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<string>;
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<string>>;
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<string>>;
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequest?: UploadThesaurusRequest,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>dir, 'dir');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>stylesheet,
      'stylesheet',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['text/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<string>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: uploadThesaurusRequest,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Uploads a new thesaurus from URL or Registry
   * Uploads a new thesaurus.
   * @param url If set, try to download from the Internet.
   * @param registryUrl If set, try to download from a registry.
   * @param registryType If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
   * @param registryLanguage Languages to download from a registry.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
   * @param thesaurusInfo
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfo?: ThesaurusInfo,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<string>;
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfo?: ThesaurusInfo,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<string>>;
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfo?: ThesaurusInfo,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<string>>;
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfo?: ThesaurusInfo,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'text/xml';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>url, 'url');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>registryUrl,
      'registryUrl',
    );
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>registryType,
      'registryType',
    );
    if (registryLanguage) {
      registryLanguage.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'registryLanguage',
        );
      });
    }
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>dir, 'dir');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>stylesheet,
      'stylesheet',
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['text/xml']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/registries/vocabularies`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<string>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: thesaurusInfo,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }
}
