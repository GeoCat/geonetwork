/**
 * GeoNetwork API
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { OgcApiRecordsExceptionDto } from '../model/ogcApiRecordsExceptionDto';
// @ts-ignore
import { OgcApiRecordsRecordGeoJSONDto } from '../model/ogcApiRecordsRecordGeoJSONDto';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class RecordService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * fetch a single record
     * Fetch the record with id &#x60;recordId&#x60; in the record collection with id &#x60;catalogId&#x60;.  Use content negotiation to request HTML or GeoJSON.
     * @param catalogId local identifier of a catalog
     * @param recordId local identifier of a record
     * @param profile One or more identifiers that provide information about additional semantics (constraints, conventions, extensions), in addition to those defined by the media type, that are associated with the target resource.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRecord(catalogId: string, recordId: string, profile?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*' | 'application/geo+json' | 'text/html' | 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OgcApiRecordsRecordGeoJSONDto>;
    public getRecord(catalogId: string, recordId: string, profile?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*' | 'application/geo+json' | 'text/html' | 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OgcApiRecordsRecordGeoJSONDto>>;
    public getRecord(catalogId: string, recordId: string, profile?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*' | 'application/geo+json' | 'text/html' | 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OgcApiRecordsRecordGeoJSONDto>>;
    public getRecord(catalogId: string, recordId: string, profile?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*' | 'application/geo+json' | 'text/html' | 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (catalogId === null || catalogId === undefined) {
            throw new Error('Required parameter catalogId was null or undefined when calling getRecord.');
        }
        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling getRecord.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (profile) {
            profile.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'profile');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*',
            'application/geo+json',
            'text/html',
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/ogcapi-records/collections/${this.configuration.encodeParam({name: "catalogId", value: catalogId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/items/${this.configuration.encodeParam({name: "recordId", value: recordId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OgcApiRecordsRecordGeoJSONDto>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
